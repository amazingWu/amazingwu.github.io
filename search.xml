<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[maven打造可执行war包]]></title>
      <url>%2F2017%2F04%2F09%2Fmaven%E6%89%93%E9%80%A0%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E5%8C%85%2F</url>
      <content type="text"><![CDATA[在开发java Web时，有时我们会使用嵌入式jetty来运行，项目完成后，如果能够直接运行war包从而启动jetty来运行war包那就非常完美了，本文将讲解如何在项目中整合jetty 9，并构造可执行的war包（打包前和打包后都能随时启动）。1.首先添加jetty 9的依赖（本文暂时只用到了jetty的以下依赖，读者根据自己的项目需要增加）12345678910&lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-server&lt;/artifactId&gt; &lt;version&gt;9.2.7.v20150116&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;version&gt;9.2.7.v20150116&lt;/version&gt;&lt;/dependency&gt; 2.项目中使用jetty 9。 首先我封装了自己的JettyServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class EmbeddedServer &#123; //public static final Logger logger = LoggerFactory.getLogger(EmbeddedServer.class); // private static final int DEFAULT_BUFFER_SIZE = 16192; protected final Server server = new Server(); public EmbeddedServer(int port,String path) throws IOException&#123; this(port,path,false,null); &#125; /** * use war to start * @param port * @param isWar * @param warPath * @throws IOException */ public EmbeddedServer(int port,boolean isWar,String warPath) throws IOException&#123; this(port,null,isWar,warPath); &#125; private EmbeddedServer(int port, String path,boolean isWar,String warPath) throws IOException &#123; Connector connector = getConnector(port); server.addConnector(connector); WebAppContext application = getWebAppContext(path,isWar,warPath); server.setHandler(application); server.setStopAtShutdown(true); &#125; protected WebAppContext getWebAppContext(String path,boolean isWar,String warPath) &#123; WebAppContext application; if(isWar)&#123; application=new WebAppContext(); application.setWar(warPath); return application; &#125;else&#123; application = new WebAppContext(path, "/"); application.setConfigurationDiscovered(true); application.setParentLoaderPriority(true); application.setClassLoader(Thread.currentThread().getContextClassLoader()); return application; &#125; &#125; protected Connector getConnector(int port) throws IOException &#123; HttpConfiguration http_config = new HttpConfiguration(); // this is to enable large header sizes when Kerberos is enabled with AD //final int bufferSize = getBufferSize(); //http_config.setResponseHeaderSize(bufferSize); //http_config.setRequestHeaderSize(bufferSize); ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(http_config)); connector.setPort(port); connector.setHost("0.0.0.0"); server.addConnector(connector); return connector; &#125; /*protected Integer getBufferSize() &#123; try &#123; Configuration configuration = ApplicationProperties.get(); return configuration.getInt("sysimple.jetty.request.buffer.size", DEFAULT_BUFFER_SIZE); &#125; catch (Exception e) &#123; // do nothing &#125; return DEFAULT_BUFFER_SIZE; &#125;*/ public void start() throws Exception &#123; server.start(); //logger.info("********************************************************"); //logger.info("The SySimple Has Started !!!"); server.join(); &#125; public void stop() &#123; try &#123; server.stop(); &#125; catch (Exception e) &#123; //logger.warn("Error during shutdown", e); &#125; &#125;&#125; 接着可以使用封装好的EmbeddedServer来启动war 12345678910111213141516171819public class StartWeb&#123; private static EmbeddedServer embeddedServer; public static void main(String[] args)&#123; //Start web server int port=3000； try&#123; if(args.length==0)&#123; //该方式能够在开发时快速启动 embeddedServer=new EmbeddedServer(port, "src/main/webapp"); &#125;else&#123; //传入war包的路径，该方法能够在打包完成后启动该war包 embeddedServer=new EmbeddedServer(port, true, args[0]); &#125; embeddedServer.start(); &#125;catch(Exception e)&#123; System.exit(0); &#125; &#125;&#125; 注意：打包后如果需要启动war包，需要使用如下的这种批处理命令来启动： 以批处理命令（start.bat）和server.war在同级目录下为例：（以下是start.bat的内容） @echo off set bat_dir=%~dp0 java -jar %bat_dir%/web.war %bat_dir%/web.war 读者可以考虑在代码中得到war包的路径，这样可以在启动时省去传参。 下面是最重要的：使用Maven构建可执行war包 总的来说可执行war包是将war包的结构仿照jar包的结构进行改变，第一个是需要在manifest中标记出主方法，第二个是编译后的代码（包，而非.class）必须放在war包的最外层，最后要能够找到项目的依赖。 ①标记主方法 通过maven-war-plugin在manifest中标记主方法入口 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;org.bit.linc.web.commons.StartWeb&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; ②拷贝（也可以移动）web的所有的代码到war包最外层（使用maven-antrun-plugin） 12345678910111213141516171819202122&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;main-class-placement&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;configuration&gt; &lt;target&gt; &lt;copy todir="$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;/"&gt; &lt;fileset dir="$&#123;project.build.directory&#125;/classes/"&gt; &lt;include name="**/*.*" /&gt; &lt;/fileset&gt; &lt;/copy&gt; &lt;/target&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; ③ 标记所有依赖的位置（将代码拷贝到war最外层后，会出现依赖的类都找不到的情况，因此需要让war包能够查找到这些依赖） 将maven-war-plugin更改为如下内容： 12345678910111213&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;org.bit.linc.web.commons.StartWeb&lt;/mainClass&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;WEB-INF/lib&lt;/classpathPrefix&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; 现在可以构建可执行war包了。 以笔者的项目为例：构建的war包中META-INF/MANIFEST.MF会变成如下内容： Manifest-Version: 1.0 Built-By: wubo Build-Jdk: 1.7.0_17 Class-Path: WEB-INF/lib/commons-0.0.2.jar WEB-INF/lib/commons-configur ation-1.8.jar WEB-INF/lib/commons-lang-2.6.jar WEB-INF/lib/commons-lo gging-1.1.1.jar WEB-INF/lib/slf4j-api-1.7.7.jar WEB-INF/lib/slf4j-log 4j12-1.7.7.jar WEB-INF/lib/log4j-1.2.17.jar WEB-INF/lib/plugins-0.0.2 .jar WEB-INF/lib/clusters-0.0.2.jar WEB-INF/lib/monitors-0.0.2.jar WE B-INF/lib/jetty-server-9.2.7.v20150116.jar WEB-INF/lib/javax.servlet- api-3.1.0.jar WEB-INF/lib/jetty-http-9.2.7.v20150116.jar WEB-INF/lib/ jetty-util-9.2.7.v20150116.jar WEB-INF/lib/jetty-io-9.2.7.v20150116.j ar WEB-INF/lib/jetty-webapp-9.2.7.v20150116.jar WEB-INF/lib/jetty-xml -9.2.7.v20150116.jar WEB-INF/lib/jetty-servlet-9.2.7.v20150116.jar WE B-INF/lib/jetty-security-9.2.7.v20150116.jar WEB-INF/lib/gson-2.3.1.j ar Created-By: Apache Maven 3.3.9 Main-Class: org.bit.linc.web.commons.StartWeb Archiver-Version: Plexus Archiver 其中的Class-Path和Main-Class均已经改变。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[maven多级项目使用slf4j+log4j，以及自定义配置文件路径]]></title>
      <url>%2F2017%2F04%2F09%2Fmaven%E5%A4%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8slf4j%2Blog4j%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%20-%20%E5%89%AF%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[我的maven多级结构如下： sysimple |--integration |--commons |--pom.xml |--plugins |--pom.xml |--web |--pom.xml |--pom.xml 其中依赖情况是： web依赖于commons和plugins。plugins依赖于commons。integration中定义了打包的方法与资源文件。 首先在sysimple/pom.xml中管理slf4j的版本： 在&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;中间添加： &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt; &lt;/dependency&gt; 由于所有的模块均引用commons，因此只需要在commons中添加slf4j的依赖即可： &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt; 下面即可使用slf4j，在需要使用的地方以如下方式使用： 123456public class StartWeb &#123; private static final Logger logger = LoggerFactory.getLogger(StartWeb.class); public static void main(String[] args)&#123; logger.info("this is a example"); &#125;&#125; 默认情况下，slf4j-log4j会在src/main/java中查找log4j.properties，如果需要指定配置文件的位置，需要在启动时手动加入Jvm的参数，我的例子中添加了-Dlog4j.configuration=file:../integration/conf/sysimple-log4j.properties。在使用绝对路径时是不需要使用file:的，linux端也不需要file:。在运行的时候，slf4j会根据你指定的路径去加载配置文件。配置文件的内容我给出以下例子， 读者可以另行查找配置文件的格式： log4j.rootLogger=INFO,system.out log4j.appender.system.out=org.apache.log4j.ConsoleAppender log4j.appender.system.out.layout=org.apache.log4j.PatternLayout log4j.appender.system.out.layout.ConversionPattern=SysimpleServer Logger--&gt;%5p{%F:%L}-%m%n log4j.logger.thisProject.file=INFO,thisProject.file.out log4j.appender.thisProject.file.out=org.apache.log4j.DailyRollingFileAppender log4j.appender.thisProject.file.out.File=../integration/logs/sysimple-logs.log log4j.appender.thisProject.file.out.layout=org.apache.log4j.PatternLayout]]></content>
    </entry>

    
  
  
</search>
