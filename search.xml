<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[机器学习初涉--层次聚类]]></title>
      <url>/2017/05/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%B6%89-%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;层次聚类算法，是通过将数据组织为若干组并形成一个相应的树来进行聚类的。 层次聚类可以自底向上也可以自顶向下，自顶向下的叫分裂的聚类算法，自底向上的叫凝聚的聚类算法。<br>&emsp;&emsp;一个简单的凝聚的层次聚类过程如图所示，一个完全层次聚类的质量由于无法对已经做的合并或分解进行调整而受到影响（简单的说就是一个点被划分到一个簇，或者两个簇合并后，后续无法进行改变，将会一直影响到聚类结束）。但是层次聚类算法没有使用准则函数，它所含的对数据结构的假设更少，所以它的通用性更强。<br><a id="more"></a><br><img src="http://img.blog.csdn.net/20160304204435219" alt="image"><br>&emsp;&emsp;凝聚的层次聚类：自底向上的策略，首先将每个对象作为一个簇，然后合并这些原子簇为越来越大的簇，直到所有的对象都在一个簇中或者达到某个终结条件。<br>&emsp;&emsp;分裂的层次聚类：顶向下的策略，首先将所有的簇都放在一个簇中，然后慢慢地细分为越来越小的簇，直到每个对象自成一簇或者达到其他的一个终结条件，例如满足了某个期望的簇数目，又或者两个最近的簇之间的距离达到了某一个阈值。<br>说明：在凝聚的层次聚类中，两个簇之间的相似度是由这里的两个不同簇中的距离最近的数据点的数据点对的相似度来定义的。在分裂的层次聚类中，簇根据某个准则进行分裂，例如这个簇中的A和B之间的距离是这个簇中所有样本间距离最远的一对，分类时以样本A和B作为新的簇，其他的样本根据距离A和B的远近划分到对应的簇中。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>用户需要提供所希望得到的聚类的单个数量和阈值作为结束条件，而这个条件对于复杂数据来说是难以判定的。</li>
<li>实现原理简单，但是偶尔会遇见合并或分裂点的抉择的困难。</li>
<li>已形成的处理就不能撤销，两个聚类之间也不能交换对象。</li>
<li>不具有很好的伸缩性，因为分类或合并时的决策需要经过检测和估算大量的对象和簇。</li>
<li>层次聚类算法由于使用距离矩阵，时间和空间复杂度都很高O(N^2),几乎不能在大数据集上使用。</li>
<li>层次聚类算法只处理符合某静态模型的簇忽略了不同簇间的信息而且忽略了粗剪的互联性（粗剪距离较近的数据对的多少）和近似度（簇间对数据对的相似度）。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
            <category> 算法 </category>
            
            <category> 聚类算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习初涉--k近邻算法]]></title>
      <url>/2017/05/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%87%BA%E6%B6%89-k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<hr>
<p>在此对k近邻算法做一个简单的总结：</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>K-近邻方法通过计算每个训练样例到待分类样品的距离，取和待分类样品距离最近的k个训练样例，k个样品中哪个类别的训练样例占多数，则待分类原组就属于哪个类别。<br>在实践中往往通过若干次实验来确定K值，取分类误差率最小的K值。<br><a id="more"></a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>KNN方法主要依靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别，因此对于类域的交叉或者重叠较多的待分类样本集来说，KNN方法更为合适。<br>不足之处是计算量较大，因为对每一个待分类的样本都要计算它到全体已知样本的距离，才能求得它的K个最邻近点。  </p>
<p>改进:<br>对于计算量大的问题目前常用的解决办法是事先对已知样本点进行剪辑，实现去除对分类作用不大的样本。<br>对样本进行组织与整理，分群分层，尽可能地将计算压缩在接近测试样本领域的小范围内。  </p>
<p>总的来说，算法的适应性较强，尤其适用于样本容量较大的自动分类问题，而那些样本容量较小的分类问题采用这种算法比较容易产生误分。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
            <category> 算法 </category>
            
            <category> 分类算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习初涉—-决策树分类]]></title>
      <url>/2017/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%B6%89%E2%80%94-%E5%86%B3%E7%AD%96%E6%A0%91%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>决策树分类我在csdn上进行过介绍，传送门：<a href="http://blog.csdn.net/u013668852/article/details/52935169" target="_blank" rel="external">决策树分类算法</a><a href="http://blog.csdn.net/u013668852/article/details/52935169" target="_blank" rel="external">http://blog.csdn.net/u013668852/article/details/52935169</a><br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
            <category> 算法 </category>
            
            <category> 分类算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动态规划-DAG-硬币问题]]></title>
      <url>/2017/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DAG-%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<blockquote>
<p>题目：有n种硬币，面值分别为V1,V2,…Vn,每种都有无限多。给定非负整数S，可以选用多少个硬币，使得面值之和恰好为S？输出硬币数目的最小值和最大值！   </p>
</blockquote>
<p> &emsp;&emsp;如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)<br><a id="more"></a><br> &emsp;&emsp;首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11)？为什么要这么问呢？两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的，本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</p>
<p> &emsp;&emsp;好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。   </p>
<p> &emsp;&emsp;那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0，表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用，因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的，即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。   </p>
<p>当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币，接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。所以d(2)=d(2-1)+1=d(1)+1=1+1=2。   </p>
<p> &emsp;&emsp;一直到这里，你都可能会觉得，好无聊，感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点，让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的(5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了:凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币，我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1.   </p>
<p> &emsp;&emsp;这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？  </p>
<p> &emsp;&emsp;具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。   </p>
<p> &emsp;&emsp;上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”，这个状态是怎么找出来的呢？我在另一篇文章中写过：根据子问题定义状态。你找到子问题，状态也就浮出水面了。   </p>
<p> &emsp;&emsp;最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1,d(3-3)+1}。没错，它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;   </p>
<p> &emsp;&emsp;有了状态和状态转移方程，这个问题基本上也就解决了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></div><div class="line"><span class="keyword">int</span> d[<span class="number">1000</span>],v[<span class="number">10</span>];  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">return</span> a &gt; b ? a : b;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dpmax</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span>(s&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-2</span>&lt;&lt;<span class="number">30</span>;</div><div class="line">    <span class="keyword">if</span> (d[s] != <span class="number">-1</span>)  </div><div class="line">        <span class="keyword">return</span> d[s];  </div><div class="line">    d[s] = <span class="number">-2</span>&lt;&lt;<span class="number">30</span>;<span class="comment">//用于设定不能走到终点的路肯定小于能走到终点的路  </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)  </div><div class="line">        <span class="keyword">if</span> (s &gt;= v[i])<span class="comment">//等号很关键 </span></div><div class="line">            <span class="comment">//根据公式：max&#123;dpmax(s-v[i])+1&#125;,代码max(d[s], dpmax(s - v[i], n)+1)中的d[s]记录的是上一个值</span></div><div class="line">            d[s] = max(d[s], dpmax(s - v[i], n)+<span class="number">1</span>);  </div><div class="line">    <span class="keyword">return</span> d[s];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> n, s, i;  </div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;s) != EOF)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n;i++)  </div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);  </div><div class="line">        <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);  </div><div class="line">        d[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//用于辨别该路能否走到终点  </span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dpmax(s, n));  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>解答转载自<a href="http://www.cnblogs.com/sunTin/p/6674945.html" target="_blank" rel="external">http://www.cnblogs.com/sunTin/p/6674945.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 动态规划 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[maven打造可执行war包]]></title>
      <url>/2017/04/07/maven%E6%89%93%E9%80%A0%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>在开发java Web时，有时我们会使用嵌入式jetty来运行，项目完成后，如果能够直接运行war包从而启动jetty来运行war包那就非常完美了，本文将讲解如何在项目中整合jetty 9，并构造可执行的war包（打包前和打包后都能随时启动）。<br><a id="more"></a><br>1.首先添加jetty 9的依赖（本文暂时只用到了jetty的以下依赖，读者根据自己的项目需要增加）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>9.2.7.v20150116<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-webapp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.2.7.v20150116<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>2.项目中使用jetty 9。</p>
<p>首先我封装了自己的JettyServer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedServer</span> </span>&#123;</div><div class="line">    <span class="comment">//public static final Logger logger = LoggerFactory.getLogger(EmbeddedServer.class);</span></div><div class="line">   <span class="comment">// private static final int DEFAULT_BUFFER_SIZE = 16192;</span></div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Server server = <span class="keyword">new</span> Server();</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmbeddedServer</span><span class="params">(<span class="keyword">int</span> port,String path)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">    	<span class="keyword">this</span>(port,path,<span class="keyword">false</span>,<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * use war to start</div><div class="line">     * <span class="doctag">@param</span> port</div><div class="line">     * <span class="doctag">@param</span> isWar</div><div class="line">     * <span class="doctag">@param</span> warPath</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmbeddedServer</span><span class="params">(<span class="keyword">int</span> port,<span class="keyword">boolean</span> isWar,String warPath)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">    	<span class="keyword">this</span>(port,<span class="keyword">null</span>,isWar,warPath);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmbeddedServer</span><span class="params">(<span class="keyword">int</span> port, String path,<span class="keyword">boolean</span> isWar,String warPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Connector connector = getConnector(port);</div><div class="line">        server.addConnector(connector);</div><div class="line">        WebAppContext application = getWebAppContext(path,isWar,warPath);</div><div class="line">        server.setHandler(application);</div><div class="line">        server.setStopAtShutdown(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> WebAppContext <span class="title">getWebAppContext</span><span class="params">(String path,<span class="keyword">boolean</span> isWar,String warPath)</span> </span>&#123;</div><div class="line">    	WebAppContext application;</div><div class="line">    	<span class="keyword">if</span>(isWar)&#123;</div><div class="line">    		application=<span class="keyword">new</span> WebAppContext();</div><div class="line">    		application.setWar(warPath);</div><div class="line">    		<span class="keyword">return</span> application;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            application = <span class="keyword">new</span> WebAppContext(path, <span class="string">"/"</span>);</div><div class="line">            application.setConfigurationDiscovered(<span class="keyword">true</span>);</div><div class="line">            application.setParentLoaderPriority(<span class="keyword">true</span>);</div><div class="line">            application.setClassLoader(Thread.currentThread().getContextClassLoader());</div><div class="line">            <span class="keyword">return</span> application;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> Connector <span class="title">getConnector</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        HttpConfiguration http_config = <span class="keyword">new</span> HttpConfiguration();</div><div class="line">        <span class="comment">// this is to enable large header sizes when Kerberos is enabled with AD</span></div><div class="line">        <span class="comment">//final int bufferSize = getBufferSize();</span></div><div class="line">        <span class="comment">//http_config.setResponseHeaderSize(bufferSize);</span></div><div class="line">        <span class="comment">//http_config.setRequestHeaderSize(bufferSize);</span></div><div class="line"></div><div class="line">        ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, <span class="keyword">new</span> HttpConnectionFactory(http_config));</div><div class="line">        connector.setPort(port);</div><div class="line">        connector.setHost(<span class="string">"0.0.0.0"</span>);</div><div class="line">        server.addConnector(connector);</div><div class="line">        <span class="keyword">return</span> connector;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*protected Integer getBufferSize() &#123;</span></div><div class="line">        try &#123;</div><div class="line">            Configuration configuration = ApplicationProperties.get();</div><div class="line">            return configuration.getInt("sysimple.jetty.request.buffer.size", DEFAULT_BUFFER_SIZE);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            // do nothing</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return DEFAULT_BUFFER_SIZE;</div><div class="line">    &#125;*/</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        server.start();  </div><div class="line">        <span class="comment">//logger.info("********************************************************");</span></div><div class="line">        <span class="comment">//logger.info("The SySimple Has Started !!!");</span></div><div class="line">        server.join();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            server.stop();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">//logger.warn("Error during shutdown", e);</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着可以使用封装好的EmbeddedServer来启动war</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> StartWeb&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> EmbeddedServer embeddedServer;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	<span class="comment">//Start web server</span></div><div class="line">	<span class="keyword">int</span> port=<span class="number">3000</span>；</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">        	<span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</div><div class="line">        	    <span class="comment">//该方式能够在开发时快速启动</span></div><div class="line">            	embeddedServer=<span class="keyword">new</span> EmbeddedServer(port, <span class="string">"src/main/webapp"</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="comment">//传入war包的路径，该方法能够在打包完成后启动该war包</span></div><div class="line">            	embeddedServer=<span class="keyword">new</span> EmbeddedServer(port, <span class="literal">true</span>, args[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">        	embeddedServer.start();</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">        	System.<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：打包后如果需要启动war包，需要使用如下的这种批处理命令来启动：</p>
<p>以批处理命令（start.bat）和server.war在同级目录下为例：（以下是start.bat的内容）</p>
<pre><code>@echo off
set bat_dir=%~dp0
java -jar  %bat_dir%/web.war %bat_dir%/web.war
</code></pre><p>读者可以考虑在代码中得到war包的路径，这样可以在启动时省去传参。</p>
<ol>
<li>下面是最重要的：使用Maven构建可执行war包</li>
</ol>
<p>总的来说可执行war包是将war包的结构仿照jar包的结构进行改变，第一个是需要在manifest中标记出主方法，第二个是编译后的代码（包，而非.class）必须放在war包的最外层，最后要能够找到项目的依赖。</p>
<p>①标记主方法</p>
<p>通过maven-war-plugin在manifest中标记主方法入口</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.bit.linc.web.commons.StartWeb<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<p>②拷贝（也可以移动）web的所有的代码到war包最外层（使用maven-antrun-plugin）</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>main-class-placement<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>prepare-package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$</span></span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml"><span class="tag"><span class="string">/$</span></span></span><span class="template-variable">&#123;project.artifactId&#125;</span><span class="xml"><span class="tag"><span class="string">/"</span>&gt;</span>  </span></div><div class="line">                        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$</span></span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml"><span class="tag"><span class="string">/classes/"</span>&gt;</span>  </span></div><div class="line">                            <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.*"</span> /&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span>  </div><div class="line">                    <span class="tag">&lt;/<span class="name">copy</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<p>③ 标记所有依赖的位置（将代码拷贝到war最外层后，会出现依赖的类都找不到的情况，因此需要让war包能够查找到这些依赖）</p>
<p>将maven-war-plugin更改为如下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.bit.linc.web.commons.StartWeb<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>WEB-INF/lib<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<p>现在可以构建可执行war包了。</p>
<p>以笔者的项目为例：<br>构建的war包中META-INF/MANIFEST.MF会变成如下内容：</p>
<pre><code>Manifest-Version: 1.0
Built-By: wubo
Build-Jdk: 1.7.0_17
Class-Path: WEB-INF/lib/commons-0.0.2.jar WEB-INF/lib/commons-configur
 ation-1.8.jar WEB-INF/lib/commons-lang-2.6.jar WEB-INF/lib/commons-lo
 gging-1.1.1.jar WEB-INF/lib/slf4j-api-1.7.7.jar WEB-INF/lib/slf4j-log
 4j12-1.7.7.jar WEB-INF/lib/log4j-1.2.17.jar WEB-INF/lib/plugins-0.0.2
 .jar WEB-INF/lib/clusters-0.0.2.jar WEB-INF/lib/monitors-0.0.2.jar WE
 B-INF/lib/jetty-server-9.2.7.v20150116.jar WEB-INF/lib/javax.servlet-
 api-3.1.0.jar WEB-INF/lib/jetty-http-9.2.7.v20150116.jar WEB-INF/lib/
 jetty-util-9.2.7.v20150116.jar WEB-INF/lib/jetty-io-9.2.7.v20150116.j
 ar WEB-INF/lib/jetty-webapp-9.2.7.v20150116.jar WEB-INF/lib/jetty-xml
 -9.2.7.v20150116.jar WEB-INF/lib/jetty-servlet-9.2.7.v20150116.jar WE
 B-INF/lib/jetty-security-9.2.7.v20150116.jar WEB-INF/lib/gson-2.3.1.j
 ar
Created-By: Apache Maven 3.3.9
Main-Class: org.bit.linc.web.commons.StartWeb
Archiver-Version: Plexus Archiver
</code></pre><p>其中的Class-Path和Main-Class均已经改变。</p>
]]></content>
      
        <categories>
            
            <category> maven </category>
            
        </categories>
        
        
        <tags>
            
            <tag> maven </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习初涉--贝叶斯分类]]></title>
      <url>/2017/04/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%B6%89-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><p> &emsp;&emsp;这个定理解决了现实生活里经常遇到的问题：已知某条件概率，如何得到两个事件交换后的概率，也就是在已知P(A|B)的情况下如何求得P(B|A)。这里先解释什么是条件概率：<br> &emsp;&emsp;P(A|B) 表示事件B已经发生的前提下，事件A发生的概率，叫做事件B发生下事件A的条件概率。其基本求解公式为：<img src="http://img.blog.csdn.net/20170506110018394" alt="image">。<br> &emsp;&emsp;贝叶斯定理之所以有用，是因为我们在生活中经常遇到这种情况：我们可以很容易直接得出P(A|B)，P(B|A)则很难直接得出，但我们更关心P(B|A)，贝叶斯定理就为我们打通从P(A|B)获得P(B|A)的道路。<br> &emsp;&emsp;下面不加证明地直接给出贝叶斯定理：<br> &emsp;&emsp;<img src="http://img.blog.csdn.net/20170506110255926" alt="image"></p>
<h2 id="朴素贝叶斯分类"><a href="#朴素贝叶斯分类" class="headerlink" title="朴素贝叶斯分类"></a>朴素贝叶斯分类</h2><h3 id="朴素贝叶斯分类的原理与流程"><a href="#朴素贝叶斯分类的原理与流程" class="headerlink" title="朴素贝叶斯分类的原理与流程"></a>朴素贝叶斯分类的原理与流程</h3><p> &emsp;&emsp;朴素贝叶斯分类是一种十分简单的分类算法，叫它朴素贝叶斯分类是因为这种方法的思想真的很朴素，朴素贝叶斯的思想基础是这样的：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。通俗来说，就好比这么个道理，你在街上看到一个黑人，我问你你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？因为黑人中非洲人的比率最高，当然人家也可能是美洲人或亚洲人，但在没有其它可用信息下，我们会选择条件概率最大的类别，这就是朴素贝叶斯的思想基础。<br> &emsp;&emsp;朴素贝叶斯分类的正式定义如下：<br>1、设<img src="http://latex.codecogs.com/gif.latex?x=\{a_1,a_2,...,a_m\}" alt="image"> 为一个待分类项，而每个a为x的一个特征属性。<br>2、有类别集合<img src="http://latex.codecogs.com/gif.latex?C=\{y_1,y_2,...,y_n\}" alt="image"><br>3、计算<img src="http://img.blog.csdn.net/20170506110424068" alt="image"><br>4、如果<img src="http://img.blog.csdn.net/20170506110503031" alt="image">，则<img src="http://img.blog.csdn.net/20170506110542350" alt="image">。   </p>
<p> &emsp;&emsp;那么现在的关键就是如何计算第3步中的各个条件概率。我们可以这么做：<br>1、找到一个已知分类的待分类项集合，这个集合叫做训练样本集。<br>2、统计得到在各类别下各个特征属性的条件概率估计。即<br><img src="http://img.blog.csdn.net/20170506110649221" alt="image"><br>3、如果各个特征属性是条件独立的，则根据贝叶斯定理有如下推导：<br><img src="http://img.blog.csdn.net/20170506110655596" alt="image"><br>因为分母对于所有类别为常数，因为我们只要将分子最大化皆可。又因为各特征属性是条件独立的，所以有：<br><img src="http://img.blog.csdn.net/20170506110659737" alt="image"><br>根据上述分析，朴素贝叶斯分类的流程可以由下图表示（暂时不考虑验证）：<br><img src="http://img.blog.csdn.net/20170506113322504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzY2ODg1Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">   </p>
<p> 可以看到，整个朴素贝叶斯分类分为三个阶段：<br> &emsp;&emsp;第一阶段——准备工作阶段，这个阶段的任务是为朴素贝叶斯分类做必要的准备，主要工作是根据具体情况确定特征属性，并对每个特征属性进行适当划分，然后由人工对一部分待分类项进行分类，形成训练样本集合。这一阶段的输入是所有待分类数据，输出是特征属性和训练样本。这一阶段是整个朴素贝叶斯分类中唯一需要人工完成的阶段，其质量对整个过程将有重要影响，分类器的质量很大程度上由特征属性、特征属性划分及训练样本质量决定。<br> &emsp;&emsp;第二阶段——分类器训练阶段，这个阶段的任务就是生成分类器，主要工作是计算每个类别在训练样本中的出现频率及每个特征属性划分对每个类别的条件概率估计，并将结果记录。其输入是特征属性和训练样本，输出是分类器。这一阶段是机械性阶段，根据前面讨论的公式可以由程序自动计算完成。<br> &emsp;&emsp;第三阶段——应用阶段。这个阶段的任务是使用分类器对待分类项进行分类，其输入是分类器和待分类项，输出是待分类项与类别的映射关系。这一阶段也是机械性阶段，由程序完成。</p>
<h3 id="估计类别下特征属性划分的条件概率及Laplace校准"><a href="#估计类别下特征属性划分的条件概率及Laplace校准" class="headerlink" title="估计类别下特征属性划分的条件概率及Laplace校准"></a>估计类别下特征属性划分的条件概率及Laplace校准</h3><p> &emsp;&emsp;这一节讨论P(a|y)的估计。<br> &emsp;&emsp;由上文看出，计算各个划分的条件概率P(a|y)是朴素贝叶斯分类的关键性步骤，当特征属性为离散值时，只要很方便的统计训练样本中各个划分在每个类别中出现的频率即可用来估计P(a|y)，下面重点讨论特征属性是连续值的情况。<br> &emsp;&emsp;当特征属性为连续值时，通常假定其值服从高斯分布（也称正态分布）。即：<br><img src="http://img.blog.csdn.net/20170506110856521" alt="image"><br> &emsp;&emsp;而<img src="http://img.blog.csdn.net/20170506111005633" alt="image"></p>
<p> &emsp;&emsp;因此只要计算出训练样本中各个类别中此特征项划分的各均值和标准差，代入上述公式即可得到需要的估计值。均值与标准差的计算在此不再赘述。</p>
<p> &emsp;&emsp;另一个需要讨论的问题就是当P(a|y)=0怎么办，当某个类别下某个特征项划分没有出现时，就是产生这种现象，这会令分类器质量大大降低。为了解决这个问题，我们引入Laplace校准，它的思想非常简单，就是对没类别下所有划分的计数加1，这样如果训练样本集数量充分大时，并不会对结果产生影响，并且解决了上述频率为0的尴尬局面。</p>
<h3 id="朴素贝叶斯分类器的应用"><a href="#朴素贝叶斯分类器的应用" class="headerlink" title="朴素贝叶斯分类器的应用"></a>朴素贝叶斯分类器的应用</h3><p>一、病人分类的例子<br> &emsp;&emsp;某个医院早上收了六个门诊病人，如下表。   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">症状　　职业　　　疾病</div><div class="line">打喷嚏　护士　　　感冒 </div><div class="line">打喷嚏　农夫　　　过敏 </div><div class="line">头痛　　建筑工人　脑震荡 </div><div class="line">头痛　　建筑工人　感冒 </div><div class="line">打喷嚏　教师　　　感冒 </div><div class="line">头痛　　教师　　　脑震荡</div></pre></td></tr></table></figure>
<p> &emsp;&emsp;现在又来了第七个病人，是一个打喷嚏的建筑工人。请问他患上感冒的概率有多大？<br>根据贝叶斯定理：  </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">P(<span class="name">A</span><span class="name">|B) = P(B|</span><span class="name">A</span>) P(<span class="name">A</span>) / P(<span class="name">B</span>)</div></pre></td></tr></table></figure>
<p> &emsp;&emsp;可得  </p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P<span class="comment">(感冒|打喷嚏x建筑工人)</span>   </div><div class="line">　　= P<span class="comment">(打喷嚏x建筑工人|感冒)</span> x P<span class="comment">(感冒)</span>   </div><div class="line">　　/ P<span class="comment">(打喷嚏x建筑工人)</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;假定”打喷嚏”和”建筑工人”这两个特征是独立的，因此，上面的等式就变成了  </p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P<span class="comment">(感冒|打喷嚏x建筑工人)</span>   </div><div class="line">　　= P<span class="comment">(打喷嚏|感冒)</span> x P<span class="comment">(建筑工人|感冒)</span> x P<span class="comment">(感冒)</span>   </div><div class="line">　  / P<span class="comment">(打喷嚏)</span> x P<span class="comment">(建筑工人)</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这是可以计算的。  </p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P(感冒|打喷嚏x建筑工人)   </div><div class="line">　　= <span class="number">0.66</span> x <span class="number">0.33</span> x <span class="number">0.5</span> / <span class="number">0.5</span> x <span class="number">0.33</span>   </div><div class="line">　　= <span class="number">0.66</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;因此，这个打喷嚏的建筑工人，有66%的概率是得了感冒。同理，可以计算这个病人患上过敏或脑震荡的概率。比较这几个概率，就可以知道他最可能得什么病。<br>这就是贝叶斯分类器的基本方法：在统计资料的基础上，依据某些特征，计算各个类别的概率，从而实现分类。</p>
<p>二、账号分类的例子<br>&emsp;&emsp;根据某社区网站的抽样统计，该站10000个账号中有89%为真实账号（设为C0），11%为虚假账号（设为C1）。<br>　　<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">C0</span> = <span class="number">0.89</span>  </div><div class="line"><span class="attr">C1</span> = <span class="number">0.11</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来，就要用统计资料判断一个账号的真实性。假定某一个账号有以下三个特征：<br>　　　　<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">F1:</span> 日志数量/注册天数   </div><div class="line"><span class="symbol">F2:</span> 好友数量/注册天数   </div><div class="line"><span class="symbol">F3:</span> 是否使用真实头像（真实头像为<span class="number">1</span>，非真实头像为<span class="number">0</span>）  </div><div class="line">F1 = <span class="number">0.1</span>   </div><div class="line">F2 = <span class="number">0.2</span>   </div><div class="line">F3 = <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;请问该账号是真实账号还是虚假账号？<br>&emsp;&emsp;方法是使用朴素贝叶斯分类器，计算下面这个计算式的值。<br>　　　　<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">P</span><span class="params">(F1|C)</span><span class="title">P</span><span class="params">(F2|C)</span><span class="title">P</span><span class="params">(F3|C)</span><span class="title">P</span><span class="params">(C)</span></span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;虽然上面这些值可以从统计资料得到，但是这里有一个问题：F1和F2是连续变量，不适宜按照某个特定值计算概率。<br>&emsp;&emsp;一个技巧是将连续值变为离散值，计算区间的概率。比如将F1分解成[0, 0.05]、(0.05, 0.2)、[0.2, +∞]三个区间，然后计算每个区间的概率。在我们这个例子中，F1等于0.1，落在第二个区间，所以计算的时候，就使用第二个区间的发生概率。<br>&emsp;&emsp;根据统计资料，可得：  </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P(<span class="name">F1</span><span class="name">|C0) = 0.5, P(F1|</span><span class="name">C1</span>) = <span class="number">0.1</span>   </div><div class="line">P(<span class="name">F2</span><span class="name">|C0) = 0.7, P(F2|</span><span class="name">C1</span>) = <span class="number">0.2</span>   </div><div class="line">P(<span class="name">F3</span><span class="name">|C0) = 0.2, P(F3|</span><span class="name">C1</span>) = <span class="number">0.9</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;因此，  </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">P(<span class="name">F1</span><span class="name">|C0) P(F2|</span><span class="name">C0</span>) P(<span class="name">F3</span><span class="name">|C0) P(C0)   </span></div><div class="line">　　= 0.5 x 0.7 x 0.2 x 0.89   </div><div class="line">　　= 0.0623  </div><div class="line">P(F1|<span class="name">C1</span>) P(<span class="name">F2</span><span class="name">|C1) P(F3|</span><span class="name">C1</span>) P(<span class="name">C1</span>)   </div><div class="line">　　= <span class="number">0.1</span> x <span class="number">0.2</span> x <span class="number">0.9</span> x <span class="number">0.11</span>   </div><div class="line">　　= <span class="number">0.00198</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，虽然这个用户没有使用真实头像，但是他是真实账号的概率，比虚假账号高出30多倍，因此判断这个账号为真。<br>三、性别分类的例子<br>&emsp;&emsp;下面是一组人类身体特征的统计资料。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">性别　　身高（英尺）　体重（磅）　　脚掌（英寸）</div><div class="line">男 　　　<span class="number">6</span> 　　　　　　<span class="number">180</span>　　　　　<span class="number">12</span> </div><div class="line">男 　　　<span class="number">5.92</span>　　　　　<span class="number">190</span>　　　　　<span class="number">11</span> </div><div class="line">男 　　　<span class="number">5.58</span>　　　　　<span class="number">170</span>　　　　　<span class="number">12</span> </div><div class="line">男 　　　<span class="number">5.92</span>　　　　　<span class="number">165</span>　　　　　<span class="number">10</span> </div><div class="line">女 　　　<span class="number">5</span> 　　　　　　<span class="number">100</span>　　　　　<span class="number">6</span> </div><div class="line">女 　　　<span class="number">5.5</span> 　　　　　<span class="number">150</span>　　　　　<span class="number">8</span> </div><div class="line">女 　　　<span class="number">5.42</span>　　　　　<span class="number">130</span>　　　　　<span class="number">7</span> </div><div class="line">女 　　　<span class="number">5.75</span>　　　　　<span class="number">150</span>　　　　　<span class="number">9</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;已知某人身高6英尺、体重130磅，脚掌8英寸，请问该人是男是女？<br>&emsp;&emsp;根据朴素贝叶斯分类器，计算下面这个式子的值。  </p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">P<span class="comment">(身高|性别)</span> x P<span class="comment">(体重|性别)</span> x P<span class="comment">(脚掌|性别)</span> x P<span class="comment">(性别)</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的困难在于，由于身高、体重、脚掌都是连续变量，不能采用离散变量的方法计算概率。而且由于样本太少，所以也无法分成区间计算。怎么办？<br>&emsp;&emsp;这时，可以假设男性和女性的身高、体重、脚掌都是正态分布，通过样本计算出均值和方差，也就是得到正态分布的密度函数。有了密度函数，就可以把值代入，算出某一点的密度函数的值。<br>&emsp;&emsp;比如，男性的身高是均值5.855、方差0.035的正态分布。所以，男性的身高为6英尺的概率的相对值等于1.5789（大于1并没有关系，因为这里是密度函数的值，只用来反映各个值的相对可能性）。  </p>
<p>&emsp;&emsp;有了这些数据以后，就可以计算性别的分类了。  </p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">P(身高=<span class="number">6</span>|男) x P(体重=<span class="number">130</span>|男) x P(脚掌=<span class="number">8</span>|男) x P(男) </div><div class="line">　　= <span class="number">6.1984</span> x e<span class="number">-9</span></div><div class="line">P(身高=<span class="number">6</span>|女) x P(体重=<span class="number">130</span>|女) x P(脚掌=<span class="number">8</span>|女) x P(女) </div><div class="line">　　= <span class="number">5.3778</span> x e<span class="number">-4</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，女性的概率比男性要高出将近10000倍，所以判断该人为女性。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
            <category> 算法 </category>
            
            <category> 分类算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[maven多级项目使用slf4j+log4j，以及自定义配置文件路径]]></title>
      <url>/2017/03/23/maven%E5%A4%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8slf4j+log4j%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%20-%20%E5%89%AF%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>我的maven多级结构如下：</p>
<pre><code>sysimple
    |--integration
    |--commons
        |--pom.xml
    |--plugins
        |--pom.xml
    |--web
        |--pom.xml
    |--pom.xml
</code></pre><p>其中依赖情况是： <a id="more"></a><br>web依赖于commons和plugins。plugins依赖于commons。integration中定义了打包的方法与资源文件。</p>
<p>首先在sysimple/pom.xml中管理slf4j的版本：</p>
<pre><code>在&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;中间添加：
    &lt;dependency&gt;
         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
         &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
         &lt;version&gt;1.7.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
         &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
         &lt;version&gt;1.7.7&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre><p>由于所有的模块均引用commons，因此只需要在commons中添加slf4j的依赖即可：</p>
<pre><code>&lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>下面即可使用slf4j，在需要使用的地方以如下方式使用：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartWeb</span> &#123;</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(StartWeb.<span class="keyword">class</span>);</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123;</div><div class="line">		logger.info(<span class="string">"this is a example"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认情况下，slf4j-log4j会在src/main/java中查找log4j.properties，如果需要指定配置文件的位置，需要在启动时手动加入Jvm的参数，我的例子中添加了-Dlog4j.configuration=file:../integration/conf/sysimple-log4j.properties。在使用绝对路径时是不需要使用file:的，linux端也不需要file:。在运行的时候，slf4j会根据你指定的路径去加载配置文件。配置文件的内容我给出以下例子， 读者可以另行查找配置文件的格式：</p>
<pre><code>log4j.rootLogger=INFO,system.out  
log4j.appender.system.out=org.apache.log4j.ConsoleAppender  
log4j.appender.system.out.layout=org.apache.log4j.PatternLayout  
log4j.appender.system.out.layout.ConversionPattern=SysimpleServer Logger--&gt;%5p{%F:%L}-%m%n 
log4j.logger.thisProject.file=INFO,thisProject.file.out  
log4j.appender.thisProject.file.out=org.apache.log4j.DailyRollingFileAppender
log4j.appender.thisProject.file.out.File=../integration/logs/sysimple-logs.log   
log4j.appender.thisProject.file.out.layout=org.apache.log4j.PatternLayout 
</code></pre>]]></content>
      
        <categories>
            
            <category> maven </category>
            
        </categories>
        
        
        <tags>
            
            <tag> maven </tag>
            
            <tag> log4j </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jvm垃圾收集算法]]></title>
      <url>/2017/03/15/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>来源：JVM虚拟机</p>
</blockquote>
<h1 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h1><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分<br>为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有<br>被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。 之所以说它<br>是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到<br>的。 它的主要不足有两个：==一个是效率问题，标记和清除两个过程的效率都不高；另一个是<br>空间问题，标记清除之后会产生大量不连续的内存碎片==，空间碎片太多可能会导致以后在程<br>序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾<br>收集动作。<br><a id="more"></a></p>
<h1 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h1><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用==内存按容<br>量划分为大小相等的两块，每次只使用其中的一块==。 ==当这一块的内存用完了，就将还存活着<br>的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉==。 这样使得每次都是<br>对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指<br>针，按顺序分配内存即可，实现简单，运行高效。 只是这种算法的代价是将内存缩小为了原<br>来的一半，未免太高了一点。 复制算法的执行过程如图3-3所示。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生<br>代中的对象98%是“朝生夕死”的。所以并不需要按照1:1的比例来划分内存空间，==而是将内存<br>分为一块较大的Eden空间和两块较小的Survivor空间==，每次使用Eden和其中一块Survivor[1]。<br>当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最<br>后清理掉Eden和刚才用过的Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是<br>8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%<br>的内存会被“浪费”。 当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每<br>次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里<br>指老年代）进行分配担保（Handle Promotion）。</p>
<h1 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h1><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。 更关键的<br>是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中<br>所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程<br>仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存<br>活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h1 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h1><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算<br>法并没有什么新的思想，==只是根据对象存活周期的不同将内存划分为几块==。 一般是把Java堆<br>分为新生代和老年代，这样就可以==根据各个年代的特点采用最适当的收集算法==。 在新生代<br>中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付<br>出少量存活对象的复制成本就可以完成收集。 而老年代中因为对象存活率高、 没有额外空间<br>对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
]]></content>
      
        <categories>
            
            <category> jvm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java对象的创建过程]]></title>
      <url>/2017/03/15/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h1><blockquote>
<p>来源：JVM虚拟机</p>
</blockquote>
<p>Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象（例如克隆、反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？<br><a id="more"></a><br>虚拟机遇到一条new指令时，==首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过==。 如果没有，那必须先执行相应的类加载过程。</p>
<p>==在类加载检查通过后，接下来虚拟机将为新生对象分配内存==。==对象所需内存的大小在类加载完成后便可完全确定==（如何确定将在2.3.2节中介绍），为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。++假设Java堆中内存是绝对规整的++，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“++==指针碰撞==++”（Bump the Pointer）。如果Java堆中的内存并++不是规整的++，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“==空闲列表==”（Free List）。 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 因此，在使用Serial、 ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
<p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案，==一种是对分配内存空间的动作进行同步处理==——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；==另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）==。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</p>
<p>内存分配完成后，==虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行==。 这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、对象的GC分代年龄等信息。 这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 关于对象头的具体内容，稍后再做详细介绍。</p>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——＜init＞方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），==执行new指令之后会接着执行＜init＞方法==，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
]]></content>
      
        <categories>
            
            <category> jvm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Storm和Spark streaming对比]]></title>
      <url>/2017/02/28/Storm%E5%92%8CSpark-streaming%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<h3 id="Spark-Streaming与Storm的应用场景"><a href="#Spark-Streaming与Storm的应用场景" class="headerlink" title="Spark Streaming与Storm的应用场景"></a>Spark Streaming与Storm的应用场景</h3><h5 id="对于Storm来说："><a href="#对于Storm来说：" class="headerlink" title="对于Storm来说："></a>对于Storm来说：</h5><p>1、建议在那种需要纯实时，不能忍受1秒以上延迟的场景下使用，比如实时金融系统，要求纯实时进行金融交易和分析<br>2、此外，如果对于实时计算的功能中，要求可靠的事务机制和可靠性机制，即数据的处理完全精准，一条也不能多，一条也不能少，也可以考虑使用Storm<br>3、如果还需要针对高峰低峰时间段，动态调整实时计算程序的并行度，以最大限度利用集群资源（通常是在小型公司，集群资源紧张的情况），也可以考虑用Storm<br>4、如果一个大数据应用系统，它就是纯粹的实时计算，不需要在中间执行SQL交互式查询、复杂的transformation算子等，那么用Storm是比较好的选择。<br><a id="more"></a></p>
<h5 id="对于Spark-Streaming来说："><a href="#对于Spark-Streaming来说：" class="headerlink" title="对于Spark Streaming来说："></a>对于Spark Streaming来说：</h5><p>1、如果对上述适用于Storm的三点，一条都不满足的实时场景，即，不要求纯实时，不要求强大可靠的事务机制，不要求动态调整并行度，那么可以考虑使用Spark Streaming<br>2、考虑使用Spark Streaming最主要的一个因素，应该是针对整个项目进行宏观的考虑，即，如果一个项目除了实时计算之外，还包括了离线批处理、交互式查询等业务功能，而且实时计算中，可能还会牵扯到高延迟批处理、交互式查询等功能，那么就应该首选Spark生态，用Spark Core开发离线批处理，用Spark SQL开发交互式查询，用Spark Streaming开发实时计算，三者可以无缝整合，给系统提供非常高的可扩展性</p>
<h3 id="Spark-Streaming与Storm的优劣分析"><a href="#Spark-Streaming与Storm的优劣分析" class="headerlink" title="Spark Streaming与Storm的优劣分析"></a>Spark Streaming与Storm的优劣分析</h3><p>事实上，Spark Streaming绝对谈不上比Storm优秀。这两个框架在实时计算领域中，都很优秀，只是擅长的细分场景并不相同。<br>Spark Streaming仅仅在吞吐量上比Storm要优秀，而吞吐量这一点，也是历来挺Spark Streaming，贬Storm的人着重强调的。但是问题是，是不是在所有的实时计算场景下，都那么注重吞吐量？不尽然。因此，通过吞吐量说Spark Streaming强于Storm，不靠谱。<br>事实上，Storm在实时延迟度上，比Spark Streaming就好多了，前者是纯实时，后者是准实时。而且，Storm的事务机制、健壮性 / 容错性、动态调整并行度等特性，都要比Spark Streaming更加优秀。<br>Spark Streaming，有一点是Storm绝对比不上的，就是：它位于Spark生态技术栈中，因此Spark Streaming可以和Spark Core、Spark SQL无缝整合，也就意味着，我们可以对实时处理出来的中间数据，立即在程序中无缝进行延迟批处理、交互式查询等操作。这个特点大大增强了Spark Streaming的优势和功能。</p>
<h3 id="Storm和Spark-streaming对比"><a href="#Storm和Spark-streaming对比" class="headerlink" title="Storm和Spark streaming对比"></a>Storm和Spark streaming对比</h3><table>
<thead>
<tr>
<th>对比点</th>
<th>storm</th>
<th>Spark Streaming</th>
</tr>
</thead>
<tbody>
<tr>
<td>\实时计算模型&emsp;</td>
<td>\纯实时，来一条数据，处理一条数据</td>
<td>\准实时，对一个时间段内的数据收集起来，作为一个RDD，再处理</td>
</tr>
<tr>
<td>\实时计算延迟度&emsp;</td>
<td>\毫秒级</td>
<td>\秒级  </td>
</tr>
<tr>
<td>\吞吐量&emsp;</td>
<td>\低</td>
<td>\高</td>
</tr>
<tr>
<td>\事务机制&emsp;</td>
<td>\支持完善</td>
<td>\支持，但不够完善</td>
</tr>
<tr>
<td>\健壮性 / 容错性&emsp;</td>
<td>\ZooKeeper，Acker，非常强</td>
<td>\Checkpoint，WAL，一般</td>
</tr>
<tr>
<td>\动态调整并行度&emsp;</td>
<td>\支持</td>
<td>\不支持</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> spark </category>
            
            <category> storm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spark </tag>
            
            <tag> storm </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
